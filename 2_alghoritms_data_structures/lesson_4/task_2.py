"""
Не оптимизированная функция recursive_reverse
0.0124367730004451
0.014560941000127059
0.037601720000566274
Оптимизированная функция recursive_reverse_mem
0.0011353429999871878
0.0011321689999022055
0.0010785309996208525
"""
# функция с мемоизацей выполнилась быстрее, посмотрим, как происходит процесс

# Изменим функцию-декоратор, чтобы посмотреть процесс мемоизации, добавив print(cache[args])
def memoize(f):
    cache = {}

    def decorate(*args):

        if args in cache:
            return cache[args]
        else:
            cache[args] = f(*args)
            print(cache[args]) # добавили вывод кэшируемого значения
            return cache[args]
    return decorate

@memoize
def recursive_reverse_mem(number):
    if number == 0:
        return ''
    return f'{str(number % 10)}{recursive_reverse_mem(number // 10)}'

# запустим первый раз с числом 5467847
print(recursive_reverse_mem(5467847))
"""
5
45
645
7645
87645
487645
7487645
7487645
"""

# запустим второй раз с этим же числом
print(recursive_reverse_mem(5467847))
"""
7487645
"""

"""
Вывод: для первого вызова функции для одного и того же числа кэш только заполняется на каждом шагу.
Для второго и последующего вызовов для этого числа готовое значение сразу будет браться из кэша, 
поэтому мемоизация даст значительный выигрыш при вызовах функции со второго раза
"""